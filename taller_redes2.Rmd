---
title: "Taller de Redes 2"
author: "Sebastián Ferrada, Hernán Sarmiento"
date: "Enero 2018"
output: 
  html_document: 
    theme: yeti
    toc: yes
---

#Redes

Una red (o _Grafo_) tiene dos componentes esenciales: sus _vértices_ o _nodos_ y sus _aristas_ o _arcos_. Los nodos representan objetos, los cuales están conectados entre sí mediante las aristas. Puede darse la posibilidad que que hayan nodos sin conexiones, pero __no__ que las aristas existan sin nodos asociados.

Por lo general, los nodos tienen algún identificador que nos permite saber a qué objeto se representa con cada nodo. Los identificadores, pueden ser números, texto u otros. Por ejemplo, podemos tener los nodos {1, 2, 3} o {"Juana", "Luisa", "María"}.

Además de los nodos y los arcos, los grafos pueden tener otras componentes o cualidades. A veces los arcos pueden ser dirigidos, es decir, si "Juana" se relaciona con "Luisa" no significa necesariamente que "Luisa" se Relacione con "Juana". Este tipo de grafos suele modelar la relación de "seguir" en redes sociales. Otros grafos son no dirigidos o bidireccionales, donde los nodos conectados se relacionan simétricamente, como las amistades de Facebook. Finalmente, tanto nodos como arcos pueden presentar atributos. Por ejemplo los nodos pueden tener más información sobre los objetos que representan: nombre, color, etc. Asimismo, los arcos pueden contener valores sobre la naturaleza de la relación: fecha de inicio, número de interacciones, etc.

#igraph

```{r message=FALSE}
#cargar igraph. En caso de no tener instalado, ejecutar install.packages("igraph")
library(igraph)
```

## Crear grafos

Para crear un grafo utilizaremos la función ``graph``. En ella podemos incluir los arcos que conectarán los nodos (vértices) del grafo y la cantidad de nodos totales.

```{r}
#crear una variable que almacene el grafo con arcos entre (1,2), (2,3), (3,1) para 3 nodos
g1 <- graph(edges = c(1,2, 2,3, 3,1), n = 3, directed = F)

#graficar el grafo
plot(g1)
```

En el caso anterior, todos los nodos estaban conectados pero podemos incluir algunos sin relación alguna con los otros agregando más elementos.

```{r}
g2 <- graph(edges = c(1,2, 2,3, 3,1), n = 8, directed = F)
plot(g2)
```

En los grafos anteriores, los arcos no tienen dirección alguna (grafo no dirigido). Ahora, crearemos un grafo dirigido cambiando el parámetro ``directed = T``. 

```{r}
g3 <- graph(edges = c(1,2, 2,3, 3,1), n = 8, directed = T)
plot(g3)
```

También podemos crear grafos donde los nodos tienen un nombre (no necesariamente números). En este caso, no necesitamos el parámetro ``n`` para la cantidad de vértices.
```{r}
g4 <- graph( c("John", "Jim", "Jim", "Jill", "Jill", "John")) # named vertices
plot(g4)
```

Sin embargo, ya que no podemos usar el parámetro ``n``, no tendremos nodos "aislados". Para esto, utilizaremos el parámetro ``isolates`` el cual recibe un vector con nombres de nodos que no tendrán conexión alguna con otros elementos en el grafo.

```{r}
#g5 <- graph( c("John", "Jim", "Jim", "Jack", "Jim", "Jack", "John", "John"), 
             #isolates=c("Jesse", "Janis", "Jennifer", "Justin") )  

g5 <- graph( c("Juan", "Maria", "Maria", "Lucas", "Lucas", "Maria", "Juan", "Juan"), 
             isolates=c("Luisa", "Teresa", "Javier", "Matias") )  
plot(g5)
```

En caso de grafos pequeños, también podríamos crearlos de forma "literal". Para esto usaremos los siguientes operadores sobre la función ``graph_from_literal``: 

* Grafo no dirigido con 2 vértices: ``A-B``
* Grafo dirigido desde A a B: ``A-+B``
* Conjunto de nodos del grafo: ``A:B:C:D``

```{r}
g6 <- graph_from_literal(a-b, b-c, c-a, a-d)
plot(g6)
```

```{r}
g7 <- graph_from_literal(a-+b, b+-c, c-+a, a+-d)
plot(g7)
```
```{r}
g8 <- graph_from_literal(a:b:c---c:d:e, f)
plot(g8)
```

## Atributos de grafos

Obtener los vértices y arcos del grafo.
```{r}
#g5 es el grafo con nombres que utilizamos anteriormente
V(g5)
E(g5)
```

Mostrar la matriz de adyacencia
```{r}
g5[]
```

O mostrar solo una fila en particular de la matriz
```{r}
g5[1,]
# o tambien g5["Juan",]
```

Cada vértice y arco puede tener sus propios atributos además del nombre de cada uno de los nodos
```{r}
V(g5)$name
```

Por ejemplo, podríamos agregar para cada nodo, un nuevo atributo llamado ``gender``
```{r}
#la asignación se realiza en el orden de las columnas que aparecen en V(g5)
V(g5)$gender <- c("male", "female", "male", "female", "female", "male", "male")
```

Y también agregar un nuevo atributo a los arcos, por ejemplo ``likes``
```{r}
#la asignación se realiza en el orden de las columnas que aparecen en E(g5)
E(g5)$views <- c(2, 1, 3, 1)
```

Si quisiéramos ver todos los atributos de vértices y arcos podríamos usar las funciones ``vertex_attr(grafo)`` y ``edge_attr(grafo)``.
```{r}
print("atributos de los nodos")
vertex_attr(g5)
print("atributos de los arcos")
edge_attr(g5)
```

## Opciones estéticas

Usando el atributo ``gender`` asignado previamente para los nodos, podríamos mostrar cada categoría en distintos colores. Para ello usaremos el parámetro ``vertex.color`` el cual requiere un vector de colores.

```{r, fig.height=5}
plot(g5,vertex.color=c( "pink", "skyblue")[1+(V(g5)$gender=="male")])
```
Además, como es posible apreciar en el grafo anterior, el tamaño de las direcciones del arco es un poco grande y también el nombre de cada nodo no queda bien ajustado. Para solucionar esto, usaremos los parámetros ``vertex.label.dist``, ``edge.arrow.size`` y ``vertex.label.color`` para corregir la distancia y el color del nombre del nodo, y  el tamaño de la dirección del arco.

```{r}
plot(g5, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=3,
  vertex.color=c( "pink", "skyblue")[1+(V(g5)$gender=="male")])
```
Tambien podemos separar el arco bidireccional en 2 unidireccionales y agregaremos el "peso" de cada uno de estos al grafo. Para esto, usaremos el parámetro ``edge.curved`` y ``edge.label``.
```{r}
plot(g5, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=3,
  vertex.color=c( "pink", "skyblue")[1+(V(g5)$gender=="male")], edge.label = E(g5)$views, edge.curved = T)
```

Alguna veces también es útil utilizar el nombre de los nodos en vez del círculo para visualizar el grafo.
```{r}
plot(g5, edge.arrow.size=.5, vertex.label.color=c("pink", "skyblue")[1+(V(g5)$gender=="male")], vertex.label = V(g5)$names, vertex.shape = "none", edge.label = E(g5)$views, edge.curved = T, vertex.label.font = 2)
```

También es posible ocultar el peso de los arcos y que el ancho de estos represente su valor.
```{r}

plot(g5, edge.arrow.size=.5, vertex.label.color=c("pink", "skyblue")[1+(V(g5)$gender=="male")], vertex.label = V(g5)$names, vertex.shape = "none",  edge.curved = T, vertex.label.font = 2, edge.width = E(g5)$views*0.8)
```
Para más información sobre las opciones estéticas, ejecutar ``help(igraph.plotting)``

## Cargar datos en igraph

Primero veremos un caso de cargar un pequeño dataset a partir de un archivo ``.csv``. Este dataset consta de 2 archivos: ``Dataset1-Media-Example-NODES.csv`` que representa la información de cada nodo tales como su identificador, nombre, etc. El segundo dataset ``Dataset1-Media-Example-EDGES.csv``, representa la red (grafo) como tal, la cual posee los arcos dirigidos entre nodos, sus pesos y tipo. Esta red representa las menciones y hyperlinks existente entre diferentes fuentes de noticias.

Primero cargaremos los datasets:
```{r}
nodes <- read.csv("data/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
edges <- read.csv("data/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)
```

Podemos inspeccionar los datasets con algunos comandos como:
```{r}
str(nodes)
str(edges)
```

Convirtiendo los ``.csv`` de nodos y vértices a un grafo en formato ``igraph``.
```{r}
net <- graph_from_data_frame(d=edges, vertices=nodes, directed=T) 
```

Inspeccionando los elementos del grafo
```{r}
V(net)
E(net)
```

Graficando el grafo, usando como etiqueta de cada nodo el nombre de cada medio de noticias a través del atributo ``media``.
```{r fig.width=10}
plot(net, edge.curved = T, vertex.label=nodes$media, vertex.size = 7, vertex.label.dist = 2)
```

Dado que pueden existir muchos arcos de ``from`` a ``to``, agruparemos estos en 1 solo arco agregando el peso mediante la suma. Además eliminaremos los loops (o arcos de un nodo consigo mismo).
```{r}
nets <- simplify(net, remove.multiple = T, remove.loops = T, edge.attr.comb=list(weight="sum","ignore"))
```

Y luego graficamos
```{r fig.width=10}
plot(nets, vertex.label=nodes$media, vertex.size = 7, vertex.label.dist = 2, edge.curved = F)
```

Ahora, revisaremos los atributos de nodos y arcos para agregar mayor información a nuestro grafo.
```{r}
print("Atributos de los nodos")
vertex_attr(nets)
print("Atributos de los arcos")
edge_attr(nets)
```

Basado en lo anterior, vemos que tenemos 3 tipos de medios noticiosos y cada uno de estos tienen un valor de audiencia que nos dice la importancia que poseen. En relación a esto, adjuntaremos tal información en nuestro grafo.

```{r fig.width=10}
coul <- c("red","blue","green")
plot(nets, vertex.label.dist = 2, edge.curved = T, vertex.color = coul[V(nets)$media.type],
     vertex.label.color = "black", edge.arrow.size = 0.5, vertex.label = V(nets)$media, vertex.size = V(nets)$audience.size*0.3)


legend("bottomleft", legend=levels(as.factor(V(nets)$type.label)) , col = coul , bty = "n", pch=20 , pt.cex = 3, cex = 1, text.col=coul , horiz = FALSE, inset = c(0.1, 0.1))
```

Adicionalmente, podríamos agregar los pesos que tiene cada arco a través del ancho de estos.
```{r fig.width=10}
coul <- c("red","blue","green")
plot(nets, vertex.label.dist = 2, edge.curved = T, vertex.color = coul[V(nets)$media.type],
     vertex.label.color = "black", edge.arrow.size = 0.9, vertex.label = V(nets)$media, vertex.size = V(nets)$audience.size*0.3, edge.width = E(nets)$weight*0.2)


legend("bottomleft", legend=levels(as.factor(V(nets)$type.label)) , col = coul , bty = "n", pch=20 , pt.cex = 3, cex = 1, text.col=coul , horiz = FALSE, inset = c(0.1, 0.1))
```

Si inspeccionamos nuevamente los atributos de nuestra red original sin agregación, es decir, el grafo ``net``, nos daremos cuenta que cada arco tiene un atributo llamado ``type``, que hace referencia al tipo de relación que existe entre 2 medios noticios.

```{r}
edge_attr(net)
```

En base a lo anterior, podríamos analizar cómo se relacionan los medios noticiosos en base al tipo que existe entre estos. Para eso, crearemos 2 grafos con los mismos nodos pero solo mostrando los arcos según el tipo que corresponda (en nuestro caso ``hyperlink`` y ``mention``)

```{r}
net.m <- net - E(net)[E(net)$type=="hyperlink"] 
net.h <- net - E(net)[E(net)$type=="mention"]
```

Luego, graficamos ambos grafos pero como la distribución en el espacio de la red es aleatoria en cada visualización, forzaremos su distribución para que esta sea igual (en ambos grafos) utilizando el algoritmo de **Fruchterman and Reingold** .



```{r fig.width=10}

coul <- c("red","blue","green")
l <- layout_with_fr(net)

plot(net.h, layout=l, main="Tie: Hyperlink", vertex.label = NA, vertex.color = coul[V(net.h)$media.type], edge.arrow.size = 0.8)

legend("bottomleft", legend=levels(as.factor(V(net.h)$type.label)) , col = coul , bty = "n", pch=20 , pt.cex = 3, cex = 1, text.col=coul , horiz = FALSE, inset = c(0.1, 0.1))

plot(net.m, vertex.color=coul[V(net.m)$media.type], layout=l, main="Tie: Mention", edge.arrow.size = 0.8, vertex.label = NA)


legend("bottomleft", legend=levels(as.factor(V(net.m)$type.label)) , col = coul , bty = "n", pch=20 , pt.cex = 3, cex = 1, text.col=coul , horiz = FALSE, inset = c(0.1, 0.1))
```

Finalmente, el mismo grafo y en base a los pesos de cada arco, podría ser visualizado como un mapa de calor (heatmap) que represente las conexiones entre nodos.

```{r}
netm <- get.adjacency(nets, attr="weight", sparse=F)
colnames(netm) <- V(net)$media
rownames(netm) <- V(net)$media
palf <- colorRampPalette(c("gold", "dark orange"))
heatmap(netm[,17:1], Rowv = NA, Colv = NA, col = palf(100),
scale="none", margins=c(10,10) )

```

## Métricas del grafo

Los grafos pueden describirse y analizarse a través de distintas métricas y propiedades:

### Densidad

La densidad es el cociente entre la cantidad de arcos presentes en el grafo y todos los arcos posibles. La cantidad de arcos posibles en una red no dirigida es $n(n-1)/2$, siendo n la cantidad de nodos del grafo. En una red dirigida es el doble: $n(n-1)$.

```{r}
edge_density(net, loops=F)
```

```{r}
ecount(net)/(vcount(net)*(vcount(net)-1)) #para grafos dirigidos
```

### Reciprocidad

La reciprocidad es la proporción de nodos que se relacionan recíprocamente en una red dirigida.

```{r}
reciprocity(net)
```

### Transitividad

La transitividad es una métrica que puede ser local o global. La transitividad global corresponde a la proporción de _triángulos_ presentes en la red, sin considerar la direccionalidad. La transitividad local indica para cada nodo el cociente entre el número de triángulos a los que pertenece y el número de triples en que el nodo es central.

```{r}
transitivity(net, type="global") #net se considera como una red no dirigida
```

```{r}
transitivity(net, type="local")
```

### Diámetro

El diámetro de una red corresponde a ya mayor distancia geodésica presente en ella. La distancia geodésica entre un par de nodos corresponde al largo del menor camino posible entre ambos nodos. El largo corresponde a la suma de los pesos de cada arco que hay que cruzar en el camino. El diámetro puede considerar o no la direccionalidad del grafo. Si los nodos están desconectados, la distancia geodésica entre ellos es infinita.

```{r}
diameter(net, directed=F, weights=NA)
```

```{r}
diameter(net, directed=F)
```

```{r}
diameter(net, directed=T, weights=NA)
```

```{r}
diameter(net, directed=T)
```

También se puede obtener la secuencia de nodos que conforman el diámetro de la red.

```{r}
diam <- get_diameter(net, directed=T)
diam
```

Podemos visualizar la red, coloreando los nodos y arcos del diámetro.

```{r fig.width=8}
vcol <- rep("gray40", vcount(net))

vcol[diam] <- "gold" # Pintamos dorados los nodos del diámetro

ecol <- rep("gray80", ecount(net))

ecol[E(net, path=diam)] <- "tomato" # Pintamos rojos los arcos del diámetro

# E(net, path=diam) busca los arcos a lo largo de un camino, en este caso: 'diam'

plot(net, vertex.color=vcol, edge.color=ecol, vertex.label=NA, edge.arrow.size=0.5)
```

### Grados

Cada nodo tiene un grado, el cual está determinado por la cantidad de conexiones que presenta en la red. El grado puede ser interno: la cantidad de aristas que _llegan_ hacia el nodo; externo: la cantidad de aristas que _salen_ desde el nodo; o total: la suma de los grados interno y externo. En R se utiliza el atributo ``mode`` para seleccionar el tipo de grado deseado, el que puede ser ``"in"``, ``"out"`` u ``"all"``.

```{r}
deg <- degree(net, mode='all')
deg
```

Podemos graficar la red, destacando los nodos según su grado total.

```{r fig.width=8}
plot(net, vertex.size=deg*3, vertex.label=NA)
```

Muchas veces es interesante conocer el histograma de los grados de los nodos, pues esto nos permite entender la manera en que estos se conectan. Por ejemplo, en redes sociales se da el efecto de que existen pocos usuarios que tienen muchos seguidores (grado interno) y muchos usuarios que tienen pocos seguidores, formando un histograma con una cola larga hacia la derecha. En el ejemplo que tenemos, el histograma se vería así:

```{r fig.width=6}
hist(deg, breaks=1:vcount(net)-1, main="Histograma del grado de los nodos")
```

## Centralidad 

## Distancias y Caminos


## Subgrupos y comunidades

Como ya hemos visto en el dataset utilizado, el grafo presenta arcos dirigidos. Previamente a utilizar las funciones para subgrupos y comunidades, debemos transformar nuestro grafo a uno no dirigido. Para ello, la manera más sencilla es crear arcos indirectos entre cada par de nodos que están conectados utilizando la función ``as.undirected`` con el parámetro ``mode="collapse"``. Además como en los casos anteriores, haremos una agregación de los pesos en los arcos.

```{r}
net.sym <- as.undirected(simplify(net,remove.loops = T), mode= "collapse", edge.attr.comb=list(weight="sum", "ignore"))
```

### Cliques
Un clique es un subgrafo en el que cada vértice está conectado a todos los demás vértices del subgrafo. Es decir, el subgrafo de $G$ inducido por un conjunto de vértices $C$ es un grafo completo. En base a esto, buscaremos los cliques presentes en el grafo considerando el que tenga el mayor número de nodos en el subgrafo.

```{r}
cl <- cliques(net.sym) #lista de cliques
cl.len <- sapply(cliques(net.sym), length) #largo de los cliques. No lo usaremos pero se puede ver el tamaño de todos
cl.largest <- largest_cliques(net.sym)  #entrega una lista de vertices del subgrafo extraido
``` 

Basado en lo anterior, primero vamos a colorear todos los nodos de una tonalidad específica. Luego le daremos un color diferente a los que están en el clique más grande y finalmente graficaremos.

```{r fig.width=10}
vcol <- rep("grey80", vcount(net.sym))  #obtenemos todos los vertices de net.sym con vcount y los pintamos gris
vcol[unlist(largest_cliques(net.sym))] <- "gold"  #desenlistamos los vertices del subgrafo y los pintamos dorado
plot(as.undirected(net.sym), vertex.label=V(net.sym)$media, vertex.color=vcol, vertex.label.dist = 2)
```

### Detección de comunidades
En la literatura existe una amplia cantidad de algoritmos para detectar comunidades en redes de grafos. Acá usaremos 2 tipos de algoritmos.